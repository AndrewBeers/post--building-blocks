<:Window bind:innerWidth="winWidth" bind:scrollY="scrollY" />
<div class="side_labels" style="grid-column: kicker;">
  <p class="heading">Input Image</p>
  <div class="input_image">
    <img src="examples/input_images/{{$example}}.png" />
  </div>
  <ExamplePicker />
</div>

<div style="grid-column: text;">
  <p class="heading">
    Attribution by Factorized Groups
  </p>

  <div class="container">
    <!-- where we render the graph lines -->
    {{#if group_data}}
    <svg class="graph" ref:graph width={{width}} height={{height}}>

        {{#each links as line,i}}
          <path d={{line.path}} opacity={{line.opacity}} stroke-width={{line.weight}} stroke="{{line.color}}" fill="none"></path>
        {{/each}}

        {{#each nodesLayout.nodes as node,i}}
          {{#if node.layer == "logit"}}
            <rect x={{node.x}} y={{node.y}} width=175 height={{node.h}} fill="{{node.i == hoveredElement && hoveredLayer == 'logit' ? "#ddd" : 'rgb(248, 248, 248)'}}"
              on:mouseover="set({hoveredLayer: 'logit', hoveredElement: node.i})"></rect>
              <!-- on:mouseout="set({hoveredLayer: '', hoveredElement: ''})"></rect> -->

            <rect x={{node.x}} y={{node.y}} width=2 height={{node.h}} fill="#111"></rect>
            <text class="layer_text" x={{node.x + 10}} y={{node.y + node.h/2}}>{{node.logit.name}}</text>
          {{else}}
            <rect x={{node.x - node.px/2}} y={{node.y - node.px/2}} 
              width={{node.w + node.px}} height={{node.h + node.px}} 
              fill="#bbb" rx=3 ry=3
              on:mouseover="set({hoveredLayer: node.layer, hoveredElement: node.i})"></rect>
              <!-- on:mouseout="set({hoveredLayer: '', hoveredElement: ''})"></rect> -->
            <image class="layer_image" xlink:href={{node.url}} x={{node.x}} y={{node.y}} width={{node.w}} height={{node.h}}></image>
          {{/if}}
        {{/each}}
      </svg>
      {{/if}}
  </div>
</div>

<figcaption class="l-page">
  groups!
</figcaption>

<style>

  .heading {
    font-size: 90%;
    font-weight: bold;
    margin-bottom: 10px;
    text-transform: capitalize;
  }
  .side_labels {
  }
  
  .example_picker {
    width: 100%;
    margin-bottom: 20px;
    white-space: pre-wrap;
  }

  .input_image {
    width: 150px;
    height: 150px;
    position: relative;
    margin-bottom: 20px;
  }

  .input_image img { 
    position: absolute; 
    top: 0;
    right: 0;
    border-radius: var(--border-radius);
  }

  .input_image .outer {
    position: absolute;
    opacity: 0.8;
    mix-blend-mode: multiply;
    image-rendering: optimizeSpeed;             /* STOP SMOOTHING, GIVE ME SPEED  */
    image-rendering: -moz-crisp-edges;          /* Firefox                        */
    image-rendering: -o-crisp-edges;            /* Opera                          */
    image-rendering: -webkit-optimize-contrast; /* Chrome (and eventually Safari) */
    image-rendering: pixelated; /* Chrome */
    image-rendering: optimize-contrast;         /* CSS3 Proposed                  */
    -ms-interpolation-mode: nearest-neighbor;   /* IE8+                           */  
    border-radius: var(--border-radius);
    overflow: hidden;
  }

  .layer_image {
    pointer-events: none;
  }
  .layer_text {
    pointer-events: none;
  }
  .graph text {
    alignment-baseline: middle;
  }


</style>

<script>
  import Sprite from './Sprite.html'
  import ExamplePicker from './ExamplePicker.html';
  import {calc_layer_size, range} from '../util';
  import { max, line, curveBasis, scaleLinear, scaleBand, nest } from 'd3'
  import {json as loadJSON} from 'd3-request';
  const layers = require('../../static/examples').layers;

  export default {
    data() {
      return {
        all_layers: layers,
        hidden_layers: ['mixed4a', 'mixed4d'],
        labels: require('../../static/examples/labels.json'),
        current_logit: null,
        hoveredLayer: "",
        hoveredElement: "",
        spacing: 30,
        width: 900,
        height: 600,
      }
    },
    
    oncreate() {
      this.store.observe('example', (example) => {
        loadJSON(`examples/groups/${example}/info.json`, (err, group_data) => {
          this.set({group_data});
        });
      });
    },

    computed: {
      logits(group_data) {
        if (!group_data) return null;
        console.log("computing", group_data)
        var keys = Object.keys(group_data.output)
        var logits = keys.map((key) => {
          var d = group_data.output[key]
          d.name = key
          return d
        }).sort(function(a,b) {
          return b.probability - a.probability
        }).slice(0, 5)
        return logits
      },

      current_logit(logits) {

      },

      // layout(group_data, logits, hidden_layers, $example, width, height, selected, hovered) {
      nodesLayout(group_data, logits, hidden_layers, $example, width, height) {
        if (!group_data) return {};
        var logitHeight = 40;
        var spacing = 5;
        var yscale = scaleBand()
          .range([0, height])
          .padding(0.2)
        
        var layerWidth = 250; // TODO: reactive

        // generate all the nodes for the hidden layers
        var nodes = []
        var nodesByLayer = {}
        hidden_layers.forEach(function(layer,j) {
          var layer_n = group_data[layer].n_groups
          yscale.domain(range(layer_n))
          // TODO: scale imagew by # of elements and height of graphic
          var imgw = height/layer_n - spacing;
          var layerNodes = range(layer_n).map(function(i) {
            var y = yscale(i);//i * (imgw + spacing) + spacing
            return {
              layer: layer,
              i: i,
              x: j * (layerWidth + yscale.bandwidth()/2) + spacing,
              y: y,
              w: yscale.bandwidth(),//imgw,
              h: yscale.bandwidth(),//imgw,
              px: 5,
              url: `examples/groups/${$example}/${layer}/each_group/${i}/icon.jpeg`
            }
          })
          nodesByLayer[layer] = layerNodes
          nodes = nodes.concat(layerNodes)
        })

        // generate the nodes for the logits
        yscale.domain(range(logits.length))
          .padding(0.3)
        var logitNodes = logits.map(function(d,i) {
          var y = yscale(i)// + yscale.bandwidth()/2 - logitHeight/2
          //i * (logitHeight + spacing) + spacing
          return {
            i: i,
            layer: "logit",
            logit: d,
            x: hidden_layers.length * (layerWidth + yscale.bandwidth()/2) + spacing,
            y: y,
            w: yscale.bandwidth(),
            h: yscale.bandwidth(),
            px: 40,
          }
        })
        nodesByLayer.logits = logitNodes
        nodes = nodes.concat(logitNodes)
        return {
          nodes: nodes,
          byLayer: nodesByLayer
        }
      },

      links(group_data, nodesLayout, logits, hidden_layers, $example, width, height, hoveredLayer, hoveredElement) {
        // console.log("hovered", hoveredLayer, hoveredElement)
        // console.log("group_data", group_data)


        if(!nodesLayout.byLayer) return [];
        var nodesByLayer = nodesLayout.byLayer
        // generate the links for the hidden layers and logits
        var links = []
        hidden_layers.forEach(function(layer, i) {
          if(i === hidden_layers.length - 1) {
            //last layer, lets connect it to the logits
            nodesByLayer.logits.forEach(function(l,i) {
              nodesByLayer[layer].forEach(function(a, j) {
                var attr = group_data.output[l.logit.name].attribution[layer][j]
                var link = {
                  i: i,
                  j: j,
                  source: a,
                  target: l,
                  attr: attr,
                  sourceLogitAttr: i == hoveredElement ? attr : 0
                }
                links.push(link)
              })
            })
            return;
          } 
          var layerLinks = []
          var layerA = layer;
          var layerB = hidden_layers[i+1]
          nodesByLayer[layerB].forEach(function(b, i) {
            var group = group_data[layerB].each_group[i]
            nodesByLayer[layerA].forEach(function(a, j) {
              var attr = group.attribution[layerA][j]
              var logitAttr = 0;
              if(hoveredLayer == "logit") {
                var logit = nodesByLayer.logits[hoveredElement].logit
                var sourceLogitAttr = group_data.output[logit.name].attribution[layerA][j]
                var targetLogitAttr = group_data.output[logit.name].attribution[layerB][i]
              }
              var link = {
                i: i,
                j: j,
                source: a,
                target: b,
                attr: attr,
                sourceLogitAttr: sourceLogitAttr,
                targetLogitAttr: targetLogitAttr
              }
              links.push(link)
            })
          })
        })
        // console.log("LINKS", links)

        var path = line()
          .x(function(d) { return d.x })
          .y(function(d) { return d.y })
          .curve(curveBasis)

        var maxLogitAttr = max(links, function(l) { return Math.abs(l.sourceLogitAttr) })
        if(hoveredLayer && hoveredLayer != "logit") {
          var maxHoveredLogitAttr = max(nodesByLayer.logits, function(d) { 
            return Math.abs(group_data.output[d.logit.name].attribution[hoveredLayer][hoveredElement])
          })
          var maxHoveredAttr = max(links, function(d) { 
            if(d.source.layer != hoveredLayer) return 0;
            return d.attr
          })
        }

        var lines = [];
        nest()
          .key(function(d) { return d.target.layer })
          .rollup(function(leaves) { return leaves })
          .entries(links)
          .forEach(function(d) {
            var targetLayer = d.key
            var targetLinks = d.value

            var maxAttr = max(targetLinks, function(l) { return Math.abs(l.attr) })
            var weightScale = scaleLinear()
              .domain([0, maxAttr])
              .range([0, 20])

            var opacityScale = scaleLinear()
              .domain([0, maxAttr])
              .range([0.05, 0.5])

            var maxI = max(targetLinks, function(l) {return l.i})
            var maxJ = max(targetLinks, function(l) {return l.j})
            // console.log("target layer", targetLayer, links, maxI, maxJ, maxAttr)

            targetLinks.forEach(function(link) {
              // var max = maxes[link.target.layer]
              // // console.log("max", max, link.i,)
              // weightScale.domain([0, max.attr])
              // opacityScale.domain([0, max.attr])
              var syscale = scaleBand()
                .domain(range(maxI+1))
                .range([2, link.source.h - 2])
                .padding(0.3)
              var tyscale = scaleBand()
                .domain(range(maxJ+1))
                .range([4, link.target.h - 2])
                .padding(0.3)

              var sx = link.source.x + link.source.w
              var sy = link.source.y + syscale(link.i) + syscale.bandwidth()/2 //link.i / maxI * link.source.h/1.5 + link.source.h/6
              // var sx = link.source.x + link.i / maxI * link.source.w/1.5 + link.source.w/6
              // var sy = link.source.y// + link.source.h/2

              var tx = link.target.x// - link.target.w/2
              var ty = link.target.y + tyscale(link.j) + tyscale.bandwidth()/2 //link.j / maxJ * link.target.h/1.5 + link.target.h/6
              // var tx = link.target.x + link.j / maxJ * link.target.w/1.5 + link.target.w/6
              // var ty = link.target.y + link.target.h/2

              var dx = tx - sx
              var points = [
                  {x: sx, y: sy},
                  {x: sx + dx/2, y: sy },
                  // {x: sx, y: sy - link.source.h*1.5 },
                  // {x: sx + (tx - sx)/2, y: sy + (ty - sy)/2},
                  // {x: tx, y: ty + link.target.h*1.5 },
                  {x: tx - dx/2, y: ty},
                  {x: tx, y: ty},
                ];
              var color = "#ccc"
              var opacity = opacityScale(Math.abs(link.attr))
              var weight = weightScale(Math.abs(link.attr))
              if(hoveredLayer == "logit") {
                // we only want to color the line if its connecting 2 hidden layers 
                // or if its connecting to the hovered logit
                if(!link.target.logit) {
                  // link between two hidden layers
                  color = link.sourceLogitAttr > 0 ? "#7FBBB4" :  "#FFAB91"
                  opacity = 0.8
                  weight = weight * Math.abs(link.targetLogitAttr)/maxLogitAttr
                } else if(hoveredElement == link.target.i) {
                  // link connects to logit
                  color = link.attr > 0 ? "#7FBBB4" :  "#FFAB91"
                  opacity = 0.8
                }
              } else if(hoveredLayer) {
                // hovering one of the hidden layers
                if(link.source.layer == hoveredLayer && link.source.i == hoveredElement)  {
                  // we want to color all of the links coming out of the hovered group
                  color = link.attr > 0 ? "#7FBBB4" :  "#FFAB91"
                  opacity = 0.8
                } else if(link.target.layer == hoveredLayer && link.target.i == hoveredElement) { 
                  // we want to color all of the links coming into the hovered group
                  color = link.attr > 0 ? "#7FBBB4" :  "#FFAB91"
                  opacity = 0.8
                } else if(link.source.layer != hoveredLayer && link.target.layer == "logit") {
                  color = link.attr > 0 ? "#7FBBB4" :  "#FFAB91"
                  opacity = 0.8
                  // if the links are for a later layer, scale their attribution by the hovered group's attribution to the logit
                  // as well as 
                  // TODO this will break with more than 2 hidden layers, we'd need to cascade the attribution thru
                  var hoveredLogitAttr = group_data.output[link.target.logit.name].attribution[hoveredLayer][hoveredElement]
                  var hoveredSourceLink = links.filter(function(l) { 
                    return l.source.layer == hoveredLayer && l.source.i == hoveredElement && l.target.i == link.source.i
                  })[0]
                  var hoveredSourceAttr = hoveredSourceLink.attr;
                  weight = weight * Math.abs(hoveredLogitAttr)/maxHoveredLogitAttr * Math.abs(hoveredSourceAttr)/maxHoveredAttr
                }
              }
              lines.push({
                link: link,
                weight: weight,
                opacity: opacity,
                color: color,
                path: path(points)
              })
            })
          })
        // console.log("lines", lines)

        // return {
        //   nodes: nodes,
        //   // links: links,
        //   lines: lines
        // }
        return lines;

      }


      // attr_max(attr_data, valid_layer_hover, layer_hover) {
      //   return attr_data.max[valid_layer_hover ? layer_hover : 'output'];
      // },
    },

    components: { ExamplePicker, Sprite }
  }
</script>