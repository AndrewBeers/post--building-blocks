<:Window bind:innerWidth="winWidth" />

<div class="l-body">
  <div class="input_image">
    <img src="examples/input_images/{{example}}.png" alt="{{example}}" />

    <svg class="pointer_container" viewBox="0 0 {{N[0]}} {{N[1]}}">
      <filter id="background_rect_blur">
        <feGaussianBlur in="SourceGraphic" stdDeviation="0.02" />
      </filter>

        {{#each range(N[0]) as x}}
        {{#each range(N[1]) as y}}
          <rect x={{x}} y={{y}} width=1 height=1
            class={{(x == pos[0] && y == pos[1])? "selected" : "unselected"}}
            on:mouseover='set({pos: [x,y]})'></rect>
        {{/each}}
        {{/each}}
    </svg>
  </div>

  <p>
    Semantic dictionaries give us a fine-grained look at an activation: what does each single neuron detect? 
    
    Building off this representation, we can also consider an activation vector as a whole. 

    Instead of visualizing individual neurons, we can instead visualize the <i>combination</i> of neurons that fire at a given spatial location.
  </p>
</div>

<div class="l-page" style="--neuron-size: {{neuron_size}}px;">
  <div class="semantic_dict">
    <div class="neuron">
      <div class="bar" style="height: 0px;"></div>
      <div class="spacer"></div>
      <span></span>
      <Sprite bg_img="examples/activations/{{example}}/mixed4d.jpeg" size="{{neuron_size}}" sprite_size="46" x={{pos[0]}} y={{pos[1]}}></Sprite>
    </div>
  
    <span class="annotation">=</span>
  
    {{#each tops as top}}
    <div class="neuron">
      <div class="bar" style="height: {{top[1]/max_act*40}}px;"></div>
      <div class="spacer"></div>
      <span>{{(top[1]+'').slice(0,4)}}</span>
      <Sprite src_class="sprite_mixed4d_neuron" n={{top[0]}} size="{{neuron_size}}" sprite_size="110" />
    </div>
  
    <span class="annotation">+</span>
    {{/each}}
  
    <span class="annotation">...</span>
  </div>
</div>

<style>    
  .input_image {
    position: relative;
    float: left;
    width: 224px;
    height: 224px;
    margin: 0 20px 20px 0;
  }

  .input_image img, .input_image svg {
    position: absolute;
    width: 100%;
    height: 100%;
  }

  .pointer_container rect {
    opacity: 0;
  }

  .pointer_container .selected {
    opacity: 1;
    fill: rgba(255, 255, 255, 0.5);
    stroke: black;
    stroke-width: 0.01px;
  }

  .semantic_dict {
    display: flex;
    justify-content: center;
  }

  .neuron {
    height: calc(var(--neuron-size) + 40);
  }

  .spacer {
    display: inline-block;
    background: #fff;
    width: 1px;
    height: 40px;
  }

  .bar {
    display: inline-block; 
    background-color: #ccc; 
    width: 20px;  
    margin-right: 2px; 
    margin-bottom: -2px;
  }

  span {
    font-size: 90%;
    color: #999;
  }

  span.annotation {
    padding: 0 10px;
    margin: auto 0;
    font-size: 2em;
    font-weight: 200;
    color: #666;
  }

  span.annotation:first-of-type { margin: auto 15px; }
</style>

<script>
  import {argmax} from 'ndarray-ops';
  import Sprite from './Sprite.html'
  import {present_vector, range, tops, fmtAct} from '../util';

  export default {
    data() {
      return {
        N: [14, 14],
        pos: [2, 3],
        max_act: undefined
      };
    },

    oncreate() {
      this.observe('example', (example) => {
        require(`../../static/examples/npy/${example}_mixed4d_activations.npy`).load((activation) => {
          this.set({activation});
        })
      });
    },    

    computed: {
      max_act(activation) {
        if (!activation) return null;
        return activation.get(...argmax(activation))
      },

      present_vector: (pos, activation) => activation && present_vector(pos, activation),
      tops: (present_vector) => present_vector ? tops(present_vector) : [],

      neuron_size (winWidth) {
        const div = document.querySelector('#ActivationVecVis .semantic_dict');
        if (!div) return 110;
        return ~~(div.getBoundingClientRect().width / 10);
      }
    },
    components: {Sprite},
    helpers: {range, fmtAct},
  }
</script>