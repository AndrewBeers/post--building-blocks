<!doctype html>

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <script src="template.v2.js"></script>

  <style>
    body {
      --gray-bg: hsl(0, 0%, 97%);
      --gray-border: rgba(0, 0, 0, 0.1);
      --border-radius: 7px;
    }

    d-title {
      overflow-y: hidden;
      padding-bottom: 0;
    }

    d-title h1, d-title p {
      grid-column: middle;
    }

    @media (max-width: 1280px) {
      d-title br.conditional {
        display: none;
      }
    }

    #Teaser {
      margin-top: 10px;
      margin-bottom: 0;
      background: var(--gray-bg);
      border-top: 1px solid var(--gray-border);
    }

    figure.full-width {
      grid-column: screen;
      padding-left: 90px;
    }

    figure.act-grids {
      overflow: hidden;
    }

    #AttributionSpatial {
      background: var(--gray-bg);
      padding: 20px 0;
      border-top: 1px solid var(--gray-border);
      border-bottom: 1px solid var(--gray-border);
    }

    #AttributionChannel {
      background: var(--gray-bg);
      padding-top: 20px;
      padding-bottom: 20px;
      border-top: 1px solid var(--gray-border);
      border-bottom: 1px solid var(--gray-border);
    }
    #AttributionGroups {
      background: var(--gray-bg);
      padding-top: 20px;
      padding-bottom: 20px;
      border-top: 1px solid var(--gray-border);
      border-bottom: 1px solid var(--gray-border);
    }


    .attribution_list {
      display: inline-block;
      list-style-type: none;
      padding: 0;
      margin: 0;
    }

    .attribution_list li {
      position: relative;
      display: flex;
      margin-bottom: 0;
      font-size: 90%;
      text-transform: capitalize;
    }

    .attribution_list li span {
      display: inline-block;
      width: 150px;
      overflow: hidden;
      white-space: nowrap;
      text-overflow: ellipsis;
      margin-right: 10px;
    }

    .attribution_list .scent {
      display: flex;
      position: relative;
      width: 40px;
      align-items: center;
    }

    .attribution_list .scent div {
      position: absolute;
      left: 0;
      background: #ccc;
      height: calc(100% - 10px);
    }

    .red { color: #c82829; }
    .orange { color: #f5871f; }
    .yellow { color: #eab700; }
    .green { color: #718c00; }
    .aqua { color: #3e999f; }
    .blue { color: #4271ae; }
    .purple { color: #8959a8; }
  </style>
</head>

<body>

<d-front-matter>
  <script type="text/json">{
  "title": "Interpretability as Interface Design",
  "description": "Description of the post",
  "password": "interfaces",
  "authors": [
    {
      "author": "Chris Olah",
      "authorURL": "https://colah.github.io/",
      "affiliation": "Google Brain",
      "affiliationURL": "https://g.co/brain"
    },
    {
      "author": "Arvind Satyanarayan",
      "authorURL": "http://arvindsatya.com",
      "affiliation": "Google Brain",
      "affiliationURL": "https://g.co/brain"
    },
    {
      "author": "Ian Johnson",
      "authorURL": "https://github.com/enjalot",
      "affiliation": "Google Cloud",
      "affiliationURL": "http://cloud.google.com/"
    },
    {
      "author": "Ludwig Schubert",
      "authorURL": "https://schubert.io/",
      "affiliation": "Google Brain",
      "affiliationURL": "https://g.co/brain"
    },
    {
      "author": "Shan Carter",
      "authorURL": "http://shancarter.com/",
      "affiliation": "Google Brain",
      "affiliationURL": "https://g.co/brain"
    },
    {
      "author": "Katherine Ye",
      "authorURL": "https://cs.cmu.edu/~kqy/",
      "affiliation": "CMU",
      "affiliationURL": "https://cs.cmu.edu/"
    },
    {
      "author": "Alexander Mordvintsev",
      "authorURL": "https://znah.net/",
      "affiliation": "Google Research",
      "affiliationURL": "https://research.google.com/"
    }
  ]
  }</script>
</d-front-matter>

<d-interstitial></d-interstitial>

<d-title>
  <h1>The Building Blocks of Interpretability</h1>
  <!-- <p>Developing a Grammar of Interfaces for Understanding Neural Networks</p> -->
  <p>
    Interpretability techniques are normally studied in isolation.<br>
    We explore the powerful interfaces that arise when you combine them â€” <br class="conditional">and the rich structure of this combinatorial space.
  </p>

  <figure id="Teaser" class="base-grid" onclick="teaserFig.set({change_label: null});"></figure>
</d-title>

<d-article>
  <p><b><i>Author list and order not finalized.</i></b></p>

  <p>
    There is a growing sense that we need to be able to explain the decisions of neural networks.

    In order to do so, we need to both construct deep abstractions and reify (or instantiate) them in rich interfaces <d-cite key="nielsen2016thought"></d-cite>.

    With a few exceptions <d-cite key="olah2015visualizing,yosinski2015understanding,carter2017using"></d-cite>, existing work on interpretability fails to do these in concert.
  </p>

  <p>
    The machine learning community has primarily focused on developing powerful methods, such as feature visualization <d-cite key="erhan2009visualizing,olah2017feature,simonyan2013deep,nguyen2015deep,mordvintsev2015inceptionism,nguyen2016plug"></d-cite> attribution <d-cite key="simonyan2013deep,zeiler2014visualizing,springenberg2014striving,selvaraju2016grad,fong2017interpretable,kindermans2017patternnet,kindermans2017reliability"></d-cite>, and dimensionality reduction <d-cite key="maaten2008visualizing"></d-cite>, for reasoning about neural networks. 

    However, these techniques have been studied as isolated threads of research, and the corresponding work of reifying them has been neglected.

    On the other hand, the human-computer interaction community has begun to explore rich user interfaces for neural networks <d-cite key="strobelt2018lstmvis,kahng2018cti,bilal2018convolutional"></d-cite>, but they have not yet engaged deeply with all the necessary abstractions. 

    To the extent these abstractions have been used, it has been in fairly standard ways.

    As a result, we have been left with impoverished interfaces (e.g., saliency maps or correlating abstract neurons) that leave a lot of value on the table. 

    Worse, many interpretability techniques have not been fully actualized into abstractions because there has not been pressure to make them generalizable or composable.
  </p>

  <p>
    In this article, we treat existing interpretability methods as fundamental and composable building blocks for rich user interfaces.

    We find that these disparate techniques now come together in a unified grammar, fulfilling complementary roles in the resulting interfaces.

    Moreover, this grammar allows us to systematically explore the space of interpretability interfaces, enabling us to evaluate whether they meet particular goals.

    We will present interfaces that show <i>what</i> the network detects and explain <i>how</i> it develops its understanding, while keeping things <i>human-scale</i>.

    For example, we will see how a network looking at a labrador retriever detects floppy ears and how that influences its classification.

    Similarly, when the network looks at an image of a woman with a punching bag, we can observe the model's bias in action: the model recognizes a feminine body which decreases the probability of a "punching bag" classification and increase "pole dancing."
  </p>

  <p>
    Although we focus on computer vision (in particular GoogLeNet<d-cite key="szegedy2015going"></d-cite>), we believe the techniques in this article generalize to other domains.
  </p>

  <h2>Making Sense of Hidden Layers</h2>

  <p>
    Much of the recent work on interpretability is concerned with a neural network's input and output layers.
    Arguably, this focus is due to the clear meaning these layers have: in computer vision, the input layer represents values for the red, green, and blue color channels for every pixel in the input image, while the output layer consists of class labels and their associated probabilities.
  </p>

  <p>
    However, the power of neural networks lies in their hidden layers -- at every layer, the network discovers a new representation of the input.

    In computer vision, we use neural networks that run the same feature detectors at every position in the image.

    We can think of each layer's learned representation as a three-dimensional cube. Each cell in the cube is an <em>activation</em>, or the amount a neuron fires.

    The x- and y-axes correspond to positions in the image, and the z-axis is the channel (or detector) being run.
  </p>

  <figure id="ActivationCube" class="l-body">
    <div id="CubeNatural" style="margin-bottom: 15px;"></div>
    <figcaption>
      The cube of activations that a neural network for computer vision develops at each hidden layer. 
      
      Different slices of the cube allow us to target the activations of individual neurons, spatial positions, or channels.
    </figcaption>
  </figure>

  <figure id="SemanticDict" class="base-grid"></figure>

  <p>
    This marriage of activations and feature visualization changes our relationship with the underlying mathematical object.

    Activations now map to iconic representations, instead of abstract indices.

    Many of these representations appear to be similar to salient human ideas, such as "floppy ear," "dog snout," or "fur."
  </p>

  <p>
    Semantic dictionaries are powerful not just because they move away from meaningless indices, but because they express a neural network's learned abstractions in its most natural form.
        
    In the case of image classification, the neural network learns a set of visual abstractions and thus images are the most natural symbols to represent them.

    Were we working with audio, clips would most likely be the more natural symbols instead.

    This is important because even when neurons correspond to a human idea -- and it might be tempting to reduce them to words -- they may express a deeper nuance that would be lost.

    For instance, the network has multiple floppy ear detectors that appear to detect slightly different levels of droopiness, length, and surrounding context to the ears.
  </p>

  <p>
    Moreover, there are some "poly-semantic" neurons which react to multiple different ideas.

    Here, we likely need to use either diversity feature visualization<d-cite key="olah2017feature,nguyen2016multifaceted"></d-cite> to reveal the variety of meanings the neuron can take, or rotate our semantic dictionaries so their components are more disentangled (we will explore this notion later in the article).

    Finally, there are some neurons that don't seem to correspond to anything we find meaningful -- this may be an extreme case of neurons needing to be disentangled, but it may also be that the network is learning abstractions alien to us.
  </p>

  <p>
    An important caveat is that in order for semantic dictionaries to be trustworthy, the basis (e.g., neurons) they operate on must have a relatively consistent meaning that is reified by feature visualization. 
    
    Recent literature has argued both for <d-cite key="szegedy2013intriguing,mikolov2013efficient"></d-cite> and against <d-cite key="jo2017measuring"></d-cite> the idea of neurons (or directions) corresponding to important ideas. 
    
    We have found <d-cite key="olah2017feature"></d-cite> that a large fraction of GoogLeNet's neurons seem to correspond to meaningful ideas.<d-footnote>For more details, see <a href="https://distill.pub/2017/feature-visualization/appendix/">the article's appendix</a> and the guided tour in <a href="https://twitter.com/ch402/status/927968700384153601">@ch402's Twitter thread</a>. We're actively investigating why GoogLeNet's neurons seem more meaningful. </d-footnote>
  <!-- </p>






  <p>
    This marriage of activations and feature visualization changes our relationship with the underlying mathematical object.

    Activations now map to iconic representations, instead of abstract indices.

    Many of these representations appear to be similar to salient human ideas, such as "floppy ear," "dog snout," or "fur."

    


  </p>

  




  <p>
    This marriage of activations and feature visualization changes our relationship with the underlying mathematical object.

    Activations now map to interpretable iconic representations, instead of abstract indices.

    Many of these representations appear to be similar to salient human ideas, such as "floppy ear," "dog snout," or "fur."
    
    (This seems to be unusually true for GoogLeNet.<d-footnote>Our previous article on feature visualization<d-cite key="olah2017feature"></d-cite> found that many neurons seem to correspond to <a href="">meaninful concepts</a>. See <a href="">the article's appendix</a> for more detail. We're not sure why GoogLeNet performs so well here, but we're actively researching it -- perhaps meaningful ideas are just more aligned with neurons.</d-footnote>)

    However, we should be cautious about reducing neurons to these natural language descriptors: even when the neurons correspond to a human idea, they may express a deeper nuance than we have canonical natural language descriptions for.
    
    For instance, the network has multiple floppy ear detectors that appear to detect slightly different levels of droopiness, length, and surrounding context to the ears.
  </p>

  <p>
    Moreover, there are some "poly-semantic" neurons which react to multiple different ideas, and some neurons that don't seem to correspond to anything we find meaningful.

    - Neurons/linear combos seem to be meaningful.
      - Some papers don't agree.
    ~~~~~~~~~~- We find GoogLeNet, this is true (many neurons correspond to meaningful ideas): cite feature vis.~~~~~~~~
    - To the extent there are polysemantic neurons: diversity feature vis.
    - Perhaps individual neurons the most meaningful units: but this is not the atom we're wedded to.
    - Some abstractions are simply alien.

    Perhaps the neural network is learning abstractions that are alien to us?


    Moreover, there are other neurons 


    
    it is important to note that these neurons may express a deeper nuance that 

    However, there are some important caveats. 

    First, even when these neurons seem to correspond to a human idea, they may express a deeper nuance than we have canonical natural language descriptions for.

    For instance, the network has multiple floppy ear detectors that appear to detect slightly different levels of droopiness, length, and surrounding context to the ears.

    Just like translating between two languages loses nuance, shoehorning these learned concepts into natural language is a lossy operation.


    
    can succinctly articulate with natural language.

    However, these concepts may not map precisely to those we are used to reasoning about, or even have good words to describe.

    Instead, they may be abstractions alien to us, or abstractions familiar to us but with deeper nuance.

    For instance, the network has multiple floppy ear detectors that seem to detect slightly different levels of droopiness and surrounding context to the ears.

    Just like translating between two languages loses nuance, shoehorning these learned concepts into natural language is a lossy operation.

    As the neural network is learning a set of visual abstractions, images (rather than words) are the most natural symbols to represent them.

    Were we working with audio, clips would most likely be the more natural symbols instead.

    In general, canonical examples are a more natural way to represent the foreign abstractions that neural networks learn than native human language.
  </p>
  -->

  <p>
    By bringing meaning to hidden layers, semantic dictionaries set the stage for our existing interpretability techniques to be composable building blocks.

    As we shall see, just like their underlying vectors, we can apply dimensionality reduction to them.

    In other cases, semantic dictionaries allow us to push these techniques further.

    For example, besides the one-way attribution that we currently perform with the input and output layers, semantic dictionaries allow us to attribute to-and-from specific hidden layers.

    In principle, this work could have been done without semantic dictionaries but it would have been unclear what the results meant.
  </p>

  <h2>What Does the Network See?</h2>

  <figure id="ActivationVecVis" class="base-grid" style="margin-top: 0;"></figure>

  <p>
    Applying this technique to all the activation vectors allows us to not only see what the network detects at each position, but also what the network understands of the input image as a whole.

    And, by working across layers, we can observe how the network's understanding evolves: from detecting edges in earlier layers, to more sophisticated shapes and object parts in the latter.
  </p>

  <!-- Include a blown up version of most interesting grid? -->

  <figure id="AllActivationGrids" class="act-grids full-width"></figure>

  <p>
    These visualizations, however, omit a crucial piece of information: the magnitude of the activations.
    By sizing each of the cells of the visualization by the magnitude of the activation vector, we can indicate how strongly the network detected features at that position:
  </p>

  <figure id="AllActivationGridsMagnitude" class="act-grids full-width"></figure>
  
<!--
  <p>
    Traditional dimensionality reduction techniques, such as principal component analysis, give us another way to understand what the network is detecting.
    For instance, to get an "overview" of the activation vectors, we can compute the first three principal components of the activations and color the image based on them.
  </p>

  <p>
    These principle components are also directions in activation space and, thus, have meaning by themselves.
    Using feature visualization, we can inspect what each of the components represents.
  </p>

  <figure class="l-page">
    <img src="images/activation-pca.png"></img>
  </figure>

  <p>
    In the end, a network's activations can be presented as semantic dictionaries with different bases.
    There are three particularly natural ones to consider: what an activation vector represents as a whole, the vector in terms of some dimensionality reduction, and finally the individual neurons themselves.
    Note, these all (approximately) describe the same object!
  </p>

  <figure id="FullVectorEq" class="l-page">
    <img src="images/vector-eq-full.png"  style="width:100%"></img>
  </figure> -->

  <h2>How Are Concepts Assembled?</h2>

  <p>
    Feature visualization helps us answer <em>what</em> the network detects, but it does not answer <em>how</em> the network assembles these individual pieces to arrive at later decisions, or <em>why</em> these decisions were made.
  </p>

  <p>
    Attribution is a set of techniques that answers such questions by explaining the relationships between neurons.

    There are a wide variety of approaches to attribution <d-cite key="simonyan2013deep,zeiler2014visualizing,springenberg2014striving,selvaraju2016grad,fong2017interpretable,kindermans2017patternnet"></d-cite> but, so far, there doesn't seem to be a clear right answer.

    In fact, there's reason to think that all our present answers aren't quite right <d-cite key="kindermans2017reliability"></d-cite>.

    We think there's a lot of important research to be done on attribution methods, but for the purposes of this article the exact approach taken to attribution doesn't matter.

    We use a fairly simple method, linearly approximating the relationship, but could easily substitute in essentially any other technique.

    Future improvements to attribution will, of course, correspondingly improve the interfaces built on top of them.
  </p>

  <h3>Spatial Attribution with Saliency Maps</h3>

  <p>
    The most common interface for attribution is called a <i>saliency map</i> -- a simple heatmap that highlights pixels of the input image that most caused the output classification.

    We see two weaknesses with this current approach.
  </p>

  <p>
    First, it is not clear that individual pixels should be the primary unit of attribution.

    The meaning of each pixel is extremely entangled with other pixels, is not robust to simple visual transforms (e.g., brightness, contrast, etc.), and is far-removed from high-level concepts like the output class.

    Second, traditional saliency maps are a very limited type of interface -- they only display the attribution for a single class at a time, and do not allow you to probe into individual points more deeply.

    As they do not explicitly deal with hidden layers, it has been difficult to fully explore their design space.
  </p>

  <p>
    We instead treat attribution as another user interface building block, and apply it to the hidden layers of a neural network. 

    In doing so, we change the questions we can pose.

    Rather than asking whether the color of a particular pixel was important for the "labrador retriever" classification, we instead ask whether the <i>high-level idea</i> detected at that position (such as "floppy ear") was important.

    This approach is similar to what Class Activation Mapping (CAM) methods<d-cite key="zhou2016learning,selvaraju2016grad"></d-cite> do but, because they interpret their results back onto the input image, they miss the opportunity to communicate in terms of the rich behavior of a network's hidden layers.
  </p>

  <figure id="AttributionSpatial" class="base-grid"></figure>

  <p>
    The above interface affords us a more flexible relationship with attribution.

    To start, we perform attribution from each spatial position of each hidden layer shown to all 1,000 output classes.

    In order to visualize this thousand-dimensional vector, we use dimensionality reduction to produce a multi-directional saliency map.

    Overlaying these saliency maps on our magnitude-sized activation grids provides an information scent<d-cite key="pirolli1999information"></d-cite> over attribution space.

    The activation grids allow us to anchor attribution to the visual vocabulary our semantic dictionaries first established.

    On hover, we update the legend to depict attribution to the output classes (i.e., which classes does this spatial position most contribute to?).

    Perhaps most interestingly, hovering displays additional saliency maps that mask the other hidden layers.

    In doing so, we interactively perform layer-to-layer attribution, in a sense shining a light into the black box of these hidden layers.

    This type of layer-to-layer attribution is a prime example of how carefully considering interface design drives the generalization of our existing abstractions for interpretability.
  </p>

  <p>
    With this diagram, we have begun to think of attribution in terms of higher-level concepts.

    However, by continuing to focus on spatial positions, these concepts remain entangled.

    At a particular position, many concepts are being detected together and this interface makes it difficult to split them apart.
  </p>

  <h3>Channel Attribution</h3>

  <p>
    Saliency maps implicitly slice our cube of activations by applying attribution to the spatial positions of a hidden layer.

    This aggregates over all channels and, as a result, we cannot tell which specific detectors <i>at each position</i> most contributed to the final output classification.
  </p>

  <p>
    An alternate way to slice the cube is by channels instead of spatial locations.

    Doing so allows us to perform <i>channel attribution</i>: how much did each detector contribute to the final output?

    (This approach is similar to contemporaneous work by Kim et al.<d-cite key="kim2017tcav"></d-cite>, who do attribution to learned combination of channels.)
  </p>

  <figure class="base-grid" id="AttributionChannel"></figure>

  <p>
    This diagram is analogous to the previous one we saw: we conduct layer-to-layer attribution but this time over channels rather than spatial positions.

    Once again, we use the icons from our semantic dictionary to represent the channels that most contribute to the final output classification.

    Hovering over an individual channel displays a heatmap of its activations overlaid on the input image.

    The legend also updates to show its attribution to the output classes (i.e., what are the top classes this channel supports?).

    Clicking a channel allows us to drill into the layer-to-layer attributions, identifying the channels at lower layers that most contributed as well as the channels at higher layers that are most supported.
  </p>

  <p>
    While these diagrams focus on layer-to-layer attribution, it can still be valuable to focus on a single hidden layer.

    For example, the teaser figure allows us to evaluate hypotheses for why one class succeeded over the other.
  </p>

  <!-- <figure class="l-page">
    <img src="images/attribution-channels.png"></img>
  </figure> -->

<!--
  <h3>Neuron Attribution</h3>

  <p>Of course, these two types attributions need not live in isolation. We can bring both spatial and channel attribution together in a single coherent interface.</p>

  <figure class="l-page" id="SpatialChannelAttribution" style="border: 1px dashed #ccc; height: 200px;"></figure>
-->

  <p>
    Attribution to spatial locations and channels can reveal powerful things about a model, especially when we combine them together.

    Unfortunately, this family of approaches is burdened by two significant problems.

    On the one hand, it is very easy to end up with an overwhelming amount of information: it would take hours of human auditing to understand the long-tail of channels that slightly impact the output.

    On the other hand, both the aggregations we have explored are extremely lossy and can miss important parts of the story.

    And, while we could avoid lossy aggregation by working with individual neurons, and not aggregating at all, this explodes the first problem combinatorially.
  </p>


  <h2>Making Things Human-Scale</h2>

  <p>
    In previous sections, we've considered three ways of slicing the cube of activations: into spatial activations, channels, and individual neurons.
    Each of these has major downsides.
    If one work's with only spatial activations or channels, they miss out on very important parts of the story.
    For example it's interesting that the floppy ear detector helped us classify an image as a Labrador retriever, but it's much more interesting when that's combined with the locations that fired to do so.
    One can try to drill down to the level of neurons to tell the whole story, but the tens of thousands of neurons are simply too much information.
    Even the hundreds of channels, before being split into individual neurons, can be overwhelming to show users!
  </p>

  <p>
    If we want to make useful interfaces into neural networks, it isn't enough to make things meaningful.
    We need to make them human scale, rather than overwhelming dumps of information.
    The key to doing so is finding more meaningful ways of breaking up our activations.
    There's a lot of reason to believe that such decompositions exist.
    Often, many channels or spatial positions will work together in a highly correlated way and are most useful to think of as one unit.
    Other channels or positions will have very little activity, and can be ignored for a high-level overview.
    So, it seems like we ought to be able to find better decompositions if we had the right tools.
  </p>

  <p>
    There is an entire field of research, called matrix factorization, that studies optimal strategies for breaking up matrices.
    By flattening our cube into a matrix of spatial locations and channels, we can apply these techniques to get more meaningful groups of neurons.
    These groups will not align as naturally with the cube as the groupings we previously looked at.
    Instead, they will be combinations of spatial locations and channels.
    Moreover, these groups are constructed to explain the behavior of a network on a particular image.
    It would not be effective to reuse the same groupings on another image; each image requires calculating a unique set of groups.
  </p>

  <figure style="grid-column:middle;">
    <div id="CubeGroups"></div>
    <figcaption>
      In addition to naturally slicing a hidden layer's cube of activations into neurons, spatial locations, or channels, we can also consider more arbitrary groupings of locations and channels.
    </figcaption>
  </figure>

  <p>
    The groups that come out of this factorization will be the atoms of the interface a user works with. Unfortunately, any grouping is inherently a tradeoff between reducing things to human scale and, because any aggregation is lossy, preserving information. Matrix factorization lets us pick what our groupings are optimized for, giving us a better tradeoff than the natural groupings we saw earlier.
  </p>

  <p>
    (Recent work has explored other techniques for finding meaningful directions in activation space <d-cite key="raghu2017svcca,kim2017tcav"></d-cite>.
    While this work primarily focuses on finding "globally" meaningful directions, we instead focus on creating smaller numbers of directions to explain individual examples.)
  </p>

  <!-- NIPS Disentagling workshop. -->


  <p>
    The goals of our user interface should influence what we optimize our matrix factorization to prioritize. For example, if we want to prioritize what the network detected, we would want the factorization to fully describe the activations. If we instead wanted to prioritize what would change the network's behavior, we would want the factorization to fully describe the gradient. Finally, if we want to prioritize what caused the present behavior, we would want the factorization to fully describe the attributions. Of course, we can strike a balance between these three objectives rather than optimizing one to the exclusion of the others.
  </p>

  <p>
    In the following diagram, we've constructed groups that prioritize the activations, by factorizing the activations
        <d-footnote>Most matrix factorization algorithms and libraries are set up to minimize the mean squared error of the reconstruction of a matrix you give them, so if you just want to optimize for one thing -- in this case, the activations -- it's quite straightforward. There's ways to hack such libraries to do more general things with clever manipulations of the matrix you give it, as we'll see below. More broadly matrix factorization is just optimization, and with custom tools you can do all sorts of things.</d-footnote>
     with non-negative matrix factorization
        <d-footnote>As the name suggests, non-negative matrix factorization (NMF) constrains its factors to be positive. This is fine for the activations of a ReLU network, which must be positive as well. Our experience is that the groups we get from NMF seem more independent and semantically meaningful than those without this constraint. Because of this constraints, groups from NMF are a less efficient at representing the activations than they would be without, but our experience is that they seem more independent and semantically meaningful.</d-footnote>
     .
    Notice how the overwhelmingly large number of neurons has been reduced to a small set of groups, concisely summarizing the story of the neural network.
  </p>

  <d-figure></d-figure>

  <figure class="l-page-outset">
    <img src="images/groups.png"></img>
  </figure>

  <p>
    This figure only focuses at a single layer but, as we saw earlier, it can be useful to look across multiple layers to understand how a neural network assembles together lower-level detectors into higher-level concepts.
  </p>

  <p>
    The groups we constructed before were optimized to understand a single layer independent of the others. To understand multiple layers together, we would like each layer's factorization to be "compatible"&mdash;to have the groups of earlier layers naturally compose into the groups of later layers. This is also something we can optimize the factorization for
      <d-footnote>
        We formalize this "compatibility" in a manner described below, although we're not confident it's the best formalization and won't be surprised if it is superseded in future work.<br>
        Consider the attribution from every neuron in the layer to the set of <i>N</i> groups we want it to be compatible with.
        The basic idea is to split each entry in the activation matrix into <i>N</i> entries on the channel dimension, spreading the values proportional to the absolute value of its attribution to the corresponding group.
        Any factorization of this matrix induces a factorization of the original matrix by collapsing the duplicated entries in the column factors.
        However, the resulting factorization tries to create separate factors when the activation of the same channel has different attributions in different places.
      </d-footnote>
    .
  </p>

  <figure id="AttributionGroups" class="base-grid"></figure>

  <p>
    In this section, we recognize that the way in which we break apart the cube of activations is an important interface decision. Rather than resigning ourselves to the natural slices of the cube of activations, we construct more optimal groupings of neurons. These improved groupings are both more meaningful and more human-scale, making it less tedious for users to understand the behavior of the network.
  </p>

  <h2>The Space of Interpretability Interfaces</h2>

  <p>
    The interface ideas presented in this article combine building blocks such as feature visualization and attribution.

    Composing these pieces is not an arbitrary process, but rather follows a structure based on the goals of the interface.

    For example, should the interface emphasize <i>what</i> the network recognizes, prioritize <i>how</i> its understanding develops, or focus on making thing <i>human-scale</i>.

    To evaluate such goals, and understand the tradeoffs, we need to be able to <i>systematically</i> consider possible alternatives.
  </p>

  <p>We can think of an interface as a union of individual elements.</p>

  <figure>
    <img src="images/atoms.png" />
  </figure>

  <p>
    Each element displays a specific type of <i class="green">content</i> (e.g., activations or attribution) using a particular style of <i class="blue">presentation</i> (e.g., feature visualization or traditional information visualization).

    This content lives on substrates defined by how given <i class="red">layers</i> of the network are broken apart into <i class="orange">atoms</i>, and may be <i class="green">transformed</i> by a series of operations (e.g., to filter it or project it onto another substrate).

    For example, our semantic dictionaries use <span class="blue">feature visualization</span> to display the <span class="green">activations</span> of a <span class="red">hidden layer's</span> <span class="orange">neurons</span>.
  </p>

  <p>
    One way to represent this way of thinking is with a formal grammar<span id="Grammar"></span>, but we find it helpful to think about the space visually.

    We can represent the network's substrate (which layers we display, and how we break them apart) as a grid, with the content and style of presentation plotted on this grid as points and connections.
  </p>

  <figure class="l-body">
    <img src="images/design_space/empty.svg"></img>
  </figure>

  <p>
    This setup gives us a framework to begin exploring the space of interpretability interfaces step by step.

    For instance, let us consider our teaser figure again.

    Its goal is to help us compare two potential classifications for an input image.
  </p>

  <figure class="l-page">
    <img src="images/design_space/teaser.svg"></img>
  </figure>

  <p>
    In this article, we have only scratched the surface of possibilities.

    There are lots of combinations of our building blocks left to explore, and the design space gives us a way to do so systematically.
  </p>

  <!-- Neuron Attribution. -->

  <p>
    Moreover, each building block represents a broad class of techniques.

    Our interfaces take only one approach but, as we saw in each section, there are a number of alternatives for feature visualization, attribution, and matrix factorization.

    An immediate next step would be to try using these alternate techniques, and research ways to improve them.
  </p>

  <p>
    Finally, this is not the complete set of building blocks; as new ones are discovered, they expand the space.

    For example, Koh et al. suggest ways of understanding the influence of dataset examples on model behavior <d-cite key="koh2017understanding"></d-cite>.

    We can think of dataset examples as another substrate in our design space, thus becoming another building block that fully composes with the others.

    In doing so, we can now imagine interfaces that not only allow us to inspect the influence of dataset examples on the final output classification (as Koh et al. proposed), but also how examples influence the features of hidden layers, and how they influence the relationship between these features and the output.

    For example, if we consider our "Labrador retriever" image, we can not only see which dataset examples most influenced the model to arrive at this classification, but also which dataset examples most caused the "floppy ear" detectors to fire, and which dataset examples most caused these detectors to increase the "Labrador retriever" classification.
  </p>

  <figure class="l-page">
    <img src="images/design_space/dataset.svg"></img>
    <figcaption style="margin-top: 10px;">
      Introducing dataset examples as a new substrate in the design space.
      Left-to-right: an interface that helps us understand the influence of dataset examples on the output classification as presented by Koh et al
      <d-cite key="koh2017understanding"></d-cite>; an interface showing how examples influence the channels of hidden layers; and, an interface for identifying which dataset examples most caused particular detectors to increase the output classification.
    </figcaption>
  </figure>

  <p>
    Beyond interfaces for analyzing model behavior, if we add model <i>parameters</i> as a substrate, the design space now allows us to consider interfaces for <i>taking action</i> on neural networks.<d-footnote>Note that essentially all our interpretability techniques are differentiable, so you can backprop through them.</d-footnote>

    Simple such interfaces could visualize the weights learned by the model and, by making them interactive, provide a opportunity for human-in-the-loop training.
    
    For example, a human might object to a woman's presence reducing the probability of an image being classified as a "punching bag" and adjust the model parameters accordingly.

    (The danger here is that we are optimizing our model to look the way we want in our interface -- if we aren't careful, this may lead to the model fooling us!<d-footnote>Related ideas have occasionally been discussed under the term "cognitive steganography."</d-footnote>)
  </p>

  <p>
    Another exciting possibility is interfaces for comparing multiple models.

    For instance, we might want to see how a model evolves during training, or how it changes when you transfer it to a new task. 

    Or, we might want to understand how a whole family of models compares to each other.

    Existing work has primarily focused on comparing the output behavior of models<d-cite key="kapoor2010interactive,krause2016interacting,amershi2015modeltracker"></d-cite> but more recent work is starting to explore comparing their internal representations as well<d-cite key="bau2017network"></d-cite>.

    One of the unique challenges of this work is that we may want to align the atoms of each model; if we have completely different models, can we find the most analogous neurons between them?

    Zooming out, can we develop interfaces that allow us to evaluate large spaces of models at once<d-cite key="olah2015visualizing"></d-cite>?
  </p>

  <h2>Conclusion &amp; Future Work</h2>

  <p>
    There is a rich design space for interacting with enumerative algorithms, and we believe an equally rich space exists for interacting with neural networks.
  </p>

  <p>
    One reservation we have is that for interpretability interfaces to be effective, we must trust that they are telling us the whole story.

    Model behavior is extremely complex, and our current building blocks force us to show only specific aspects of it.

    An important direction for future interpretability research will be developing techniques that achieve broader coverage of model behavior.

    But, even with such improvements, we anticipate that a key marker of trustworthiness will be interfaces that do not mislead.

    Interacting with the explicit information displayed should not cause users to implicitly draw incorrect assessments about the model (we see a similar principle articulated by Mackinlay for data visualization<d-cite key="mackinlay1986automating"></d-cite>).

    For example, it is difficult to evaluate whether an interface as basic as our semantic dictionary is misleading (as many neurons it displays are polysemantic) or to what extent this can be remedied
      <d-footnote>
        Possible ways of resolving this include providing multiple icons constructed with diversity feature visualization that try to show the range of meanings of the neuron<d-cite key="olah2017feature,nguyen2016multifaceted"></d-cite> or techniques for disentangling representations into more semantically meaningful units (see e.g., the <a href="https://sites.google.com/corp/view/disentanglenips2017">NIPS workshop</a> on this subject).
      </d-footnote>
    .
  </p>

  <p>
    We have a lot of work left ahead of us to build powerful and trusthworthy interfaces for interpretability.

    But, if we succeed, interpretability promises to be a powerful tool in enabling meaningful human oversight and in building fair, safe, and aligned AI systems.
  </p>
</d-article>



<d-appendix>
  <h3>Acknowledgments</h3>
  <p>
  </p>

  <h3>Author Contributions</h3>
  <p>
  </p>

  <d-footnote-list></d-footnote-list>
  <d-citation-list></d-citation-list>
</d-appendix>

<d-bibliography src="bibliography.bib"></d-bibliography>

</body>
